% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
% Le truc au-dessus pour avoir l'option shell-escape qui permet de faire du minted.
\documentclass[12pt]{article}

% Affichage ou non des reponses aux questions & exercices
\newif\ifDispRep
%\DispReptrue  % Show the text
\DispRepfalse % Hide the text

% Version du document
\newcommand{\versiondoc}{v0.2}

% Incorporation tous éléments de préambule communs à tous mes cours
% Sans chemin relatif parce que TexStudio lancé depuis un script qui prend en compte la variable d'environnement TEXINPUTS
\usepackage{CoursLFC}

% Eléments de l'en-tête et de la page de garde spécifiques à ce doc
\newcommand{\classe}{1\textsuperscript{ère} NSI}
\newcommand{\themecours}{Exercices d'Entraînement}
\newcommand{\datedoc}{février 2024}

% Page de garde mise en page
\title
	{\vspace{2cm}
		{\Large
		\textit
			{
				\classe\hspace{0.1cm}
				\textemdash\
				\hspace{0.1cm}
				\themecours
			}
			
		\vspace{1cm}
		\huge{Algorithmique} }
		 
		\vspace{1cm}
	}
\author{\etablissement}
\date{
	\auteur,
	\datedoc,
	\footnotesize{\textit{\versiondoc}} 
	\vspace{3cm}
	}

% Header & Footer
\lfoot{\etabshort}
\cfoot{\thepage}
\rfoot{\classe, \anneescol}
\renewcommand{\footrulewidth}{0.2pt}
\lhead{}
\chead{}
\rhead{}
\renewcommand{\headrulewidth}{0pt}

\begin{document}
	
	\maketitle
	% pas de footer sur la première page
	\thispagestyle{empty}
	\vspace{\baselineskip}
	\begin{MaReponse}
		\centering
		\vspace{\baselineskip}
		\textbf{Version incluant les réponses aux exercices.}
		\vspace{\baselineskip}
	\end{MaReponse}
	
	%\tableofcontents
	
	\pagebreak
	
	
	% Début du contenu du document
	%\section{Variants \& Invariants de boucles}
	\begin{MonExo}[Docstring \& Tests]
		Soit la fonction de calcul de puissance suivante (dont on a étudié l'algorithme en cours):
		\MonPython{Exos_001_PuissanceNoDocStrg.py}
		
		\begin{alphenum}
			\item Rédiger la docstring d'une telle fonction;
			\item Déterminer un jeu de tests pour cette fonction -- en d'autres termes, compléter le tableau suivant qui liste les couples (x, n) qu'il conviendra d'utiliser pour convenablement tester cette fonction.
		\end{alphenum}
		
		\centering
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{x} & \textbf{n} & \textbf{Résultat attendu}\\
			\hline
			2 & 2 & 4\\
			\hline
			...... & ...... & ......\\
			\hline
		\end{tabular}
	\end{MonExo}
	
	\begin{MaReponse}
		\MonPython{Exos_002_PuissanceDocStrg.py}
		Il n'y a pour le jeu de tests pas "une" bonne réponse, mais ce qu'on va chercher à faire c'est effectuer au moins deux tests de valeurs "normales" dont un avec une grande valeur (en plus, donc, du (2,2) de l'énoncé), ainsi que des tests avec les valeurs aux limites -- en l'occurrence 0 et 1 -- associées à des valeurs choisies au hasard. On pourra donc proposer quelque chose comme:
		
		\centering
		\begin{tabular}{|c|c|m{4cm}|}
			\hline
			\textbf{x} & \textbf{n} & \textbf{Résultat attendu}\\
			\hline
			2 & 2 & 4\\
			\hline
			27 & 7 & 10.460.353.203\\
			\hline
			21 & 0 & 1 (tout nombre élevé à la puissance 0 vaut 1)\\
			\hline
			35 & 1 & 35 \\
			\hline
			1 & 12 & 1 \\
			\hline
			0 & 99 & 0\\
			\hline
			0 & 0 & 1 (tout nombre élevé à la puissance 0 vaut 1 -- même 0)\\
			\hline
		\end{tabular}
	\end{MaReponse}


	\begin{MonExo}[Variant \& invariant de boucle]
		Soit la fonction suivante:
		\MonPython{Exos_003_SommeEltsListe.py}
		\begin{alphenum}
			\item Donner un variant de boucle pour cette fonction et montrer qu'elle se termine systématiquement;
			\begin{MonAmp}{Rappel}
				On rappelle qu'un variant de boucle est une quantité entière positive qui décroît strictement à mesure qu'on passe dans la boucle, ce qui permet de justifier que la boucle, tôt ou tard, se terminera.
			\end{MonAmp}
			\item Donner un invariant de boucle pour cette fonction et montrer qu'elle est correcte.
			\begin{MonAmp}{Rappel}
				On rappelle qu'un invariant de boucle est une quantité ou une propriété qui est vraie avant et après chaque itération de la boucle -- et en particulier \textit{avant} que l'on rentre dans la boucle, et \textit{après} sa dernière itération. Il permet de justifier que le résultat voulu sera atteint. On procède pour cette technique en quatre étapes:
				\begin{enumerate}
					\item On choisit l'invariant:
					\begin{itemize}
						\item Comprendre clairement le but de la boucle -- qu'est-elle censée accomplir? Quel est le résultat attendu?
						\item Partir "de la fin", c'est-à-dire du résultat attendu et identifier quelle quantité est "construite" au fur et à mesure des itérations de la boucle pour constituer ce résultat.
						\item Ceci devrait vous mettre sur la voie de votre invariant -- une propriété (somme d'éléments déjà traités, ordre d'éléments dans une liste...) qui ne change pas malgré les itérations de la boucle.
					\end{itemize}
					\item On montre que l’invariant est vérifié avant la boucle (initialisation);
					\item On montre que si l'invariant est vérifié \textit{avant }un passage dans la boucle, alors il est préservé \textit{après }le passage dans la boucle;
					\item On peut conclure sur la valeur finale à la sortie de la boucle.
				\end{enumerate}
			\end{MonAmp}
		\end{alphenum}
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{alphenum}
			\item Variant de boucle -- on est dans le cas ultra-classique du parcours d'une liste par indice, le variant est donc la quantité $len(liste) - i - 1$: il est en effet positif au départ (au pire nul si la liste est vide), et il décroît strictement à chaque itération de la boucle puisque $len(liste)$ reste constant et que $i$ est incrémenté de 1 à chaque fois. Il va donc atteindre 0, ce qui terminera la boucle.
			\item Décomposons la démarche:
			\begin{enumerate}
				\item Choix de l'invariant: le but de la boucle est le calcul de la somme des éléments de la liste, et c'est la variable \texttt{res} qui est construite pour atteindre ce résultat: à chaque étape elle contient la somme des éléments d'indice de 0 à \texttt{i} de la liste. On peut donc dire que l'invariant de boucle est: "la variable \texttt{res} contient la somme des éléments d'indice de 0 à \texttt{i} de la liste";
				\item Avant la première itération de la boucle, \texttt{i} vaut 0 et \texttt{res} aussi -- donc on peut dire que l'invariant est vérifié;
				\item Si res contient les i premiers éléments de la liste et que l'on passe dans la boucle une fois supplémentaire, \texttt{i} et \texttt{res} deviennent respectivement: $i' = i + 1$ et $res' = res + liste[i'] = res + liste[i+1]$ -- et donc l'invariant est bien vérifié à la fin de l'itération de la boucle.
				\item A la fin de la boucle i vaut $(n-1)$ donc l'invariant s'exprime "la variable \texttt{res} contient la somme des éléments d'indice de 0 à \texttt{(n-1)} de la liste" -- soit tous les éléments de la liste, et donc la fonction est correcte.
			\end{enumerate}
		\end{alphenum}
	\end{MaReponse}

	\begin{MonExo}[Variant \& invariant de boucle --- suite...]
		Soit la fonction suivante:
		\MonPython{Exos_004_RechercheDiviseur.py}
		\begin{alphenum}
			\item Donner un variant de boucle pour cette fonction et montrer qu'elle se termine systématiquement;
			\item Donner un invariant de boucle pour cette fonction et montrer qu'elle est correcte.
			\begin{MonAmp}{Indice}
				On rappelle qu'un invariant de boucle n'est pas nécessairement une formule mathématique -- il peut aussi être une propriété que l'on pourrait exprimer par une phrase du genre (où bien entendu il faut remplir les trous): "Quel que soit l'entier k tel que 2 $\leq$ k $\leq$ \uline{\ \ \ \ }, k n'est pas\uline{\ \ \ \ }".
			\end{MonAmp}
			\item (question bonus 1) Cette boucle "\texttt{while}" semble assez artificielle -- on dirait presque qu'elle n'est là que pour vous forcer à travailler sur la notion de variant de boucle... Quelle est la boucle "\texttt{for}" équivalente qu'on utiliserait plus logiquement dans un tel cas?
			\item (question bonus 2) Cette fonction n'est pas franchement optimale... Comment remplacer la condition "\texttt{while i < nb:}" pour lui faire faire nettement moins de tests tout en gardant le bon résultat?
		\end{alphenum}
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{alphenum}
			\item Variant de boucle -- situation assez simple: la quantité $nb - i$ débute à la valeur $nb - 2$ qui est nécessairement positive puisqu'il est spécifié que nb est strictement supérieur à 1; cette quantité décroît strictement à chaque itération de la boucle puisque $nb$ reste constant et que $i$ est incrémenté de 1 à chaque fois. Il va donc atteindre 0, ce qui terminera la boucle.
			\item Décomposons la démarche:
			\begin{enumerate}
				\item Choix de l'invariant: le but de la boucle est de trouver le diviseur le plus petit diviseur possible de nb, donc à chaque étape de la boucle, aucun nombre plus petit que celui que l'on est en train de considérer n'est diviseur de nb. On peut donc exprimer l'invariant: "quel que soit l'entier k tel que 2 $\leq$ k $\leq$ (i-1), k n'est pas un diviseur de nb";
				\item Avant la première itération de la boucle, \texttt{i} vaut 2, donc il n'existe aucun entier k tel que 2 $\leq$ k $\leq$ (i-1) -- donc on peut dire que l'invariant est vérifié;
				\item Si l'invariant est vérifié pour une valeur de i, alors pour la valeur suivante $i' = i + 1$, deux cas sont possibles:
				\begin{itemize}
					\item Soit i est un diviseur de nb et la fonction le renvoie et donc se termine (donc la question de l'invariant ne se pose plus);
					\item Soit i n'est pas un diviseur de nb -- et la boucle se poursuit et l'invariant est vérifié: "quel que soit l'entier k tel que 2 $\leq$ k $\leq$ (i'-1), k n'est pas un diviseur de nb" (puisque $i'-1 = i$).
				\end{itemize}
				\item A la fin de la boucle, dans l'hypothèse où on n'est pas sorti de la fonction, i vaut $nb$, donc l'invariant s'exprime "quel que soit l'entier k tel que 2 $\leq$ k $\leq$ (nb-1), k n'est pas un diviseur de nb" -- et donc nb est par définition un nombre premier.
			\end{enumerate}
			\item On fait varier i de 2 à nb-1 donc la boucle correspondante s'écrirait "\texttt{for i in range(2, nb)}".
			\item Il est évident que le plus grand diviseur d'un nombre (autre que lui-même) est sa moitié s'il est pair, ou son tiers s'il est impair mais un multiple de trois, etc. En tout état de cause, aucun nombre ne pourra avoir de diviseur strictement supérieur à sa moitié (ou la partie entière de sa moitié dans le cas d'un nombre impair). En écrivant la condition "\texttt{while i <= (nb // 2)}" on économiserait presque la moitié des opérations effectuées par la boucle tout en maintenant le résultat correct...
		\end{alphenum}
	\end{MaReponse}
	
	\begin{MonExo}[Variant \& invariant de boucle --- encore un!]
		Soit la fonction suivante:
		\MonPython{Exos_005_RechercheMax.py}
		Donner un invariant de boucle pour cette fonction et montrer qu'elle est correcte.
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{enumerate}
			\item Choix de l'invariant: le but de la boucle est de trouver le maximum de la liste, donc avant chaque étape de la boucle, la variable \texttt{res} contient le maximum des éléments d'indice de 0 à \texttt{i-1} de la liste;
			\item Avant la première itération de la boucle, \texttt{i} vaut 0, donc la liste d'éléments dont l'indice est compris entre 0 et (i-1) est vide -- donc on peut dire que l'invariant est vérifié;
			\item Si l'invariant est vérifié pour une valeur de i, alors pour la valeur suivante $i' = i + 1$, deux cas sont possibles:
			\begin{itemize}
				\item Soit lst[i] $\leq$ res et donc, par définition, l'invariant reste vérifié (le maximum n'a pas changé);
				\item Soit lst[i] > res, res prend alors la valeur lst[i] qui est le nouveau maximum des éléments d'indice compris entre 0 et (i'-1) (donc i), et donc l'invariant est vérifié aussi.
			\end{itemize}
			\item A la fin de la dernière itération de la boucle, i vaut len(lst), donc res contient le maximum des éléments d'indice de 0 à \texttt{len(lst)-1} de la liste -- donc de toute la liste, et donc la boucle est correcte.
		\end{enumerate}
	\end{MaReponse}
	
	\begin{MonExo}[Complexité -- inversion de liste]
		Soit la fonction suivante:
		\MonPython{Exos_010_InvertLst.py}
		\begin{alphenum}
			\item Montrer, en utilisant un invariant de boucle, qu'elle fait bien ce que sa docstring spécifie.
			\item Compter son nombre d'opérations élémentaires, et en déduire sa complexité (préciser sa dénomination et sa notation en "$\mathcal{O}$").
		\end{alphenum}
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{alphenum}
			\item L'invariant de boucle est la propriété, pour une valeur de i et après la réalisation de la boucle: "res est une liste contenant les i+1 derniers éléments de lst, dans l'ordre inverse". Initialisation: i=0, res contient uniquement lst[len(lst) - 1], soit le dernier élément de lst, donc l'invariant est vérifié. Si c'est vérifié pour i, lorsqu'on passe à i' = i + 1, on ajoute à la fin de res l'élément de lst d'indice (len(lst) - i' - 1) qui est le (i' + 1)\textsuperscript{ème} en partant de la fin, et on a donc rallongé res de 1 (sa longueur est donc maintenant i'+1) -- l'invariant est donc bien vérifié à i'. La boucle se termine lorsque i =  après len(lst) itérations, quand i est égal à len(lst) - 1, et donc à ce moment l'invariant s'exprime "res est une liste contenant les (len(lst)) derniers éléments de lst, dans l'ordre inverse" -- donc tous les éléments, et donc la boucle est correcte.
			\item Si l'on compte strictement les opérations on a:
			\begin{itemize}
				\item Deux opérations en dehors de la boucle (\texttt{res = []} et \texttt{return res});
				\item Une opération à l'intérieur de chaque itération de la boucle (le append sur la lsite res);
				\item Deux opérations à chaque itération de la boucle -- l'incrémentation de i et sa comparaison avec len(lst).
			\end{itemize}
			Si on note n la longueur de lst, la boucle est réalisée n fois et donc le nombre d'opérations est: $3 \times n + 2$ -- et donc on en déduit que la complexité est en $\mathcal{O}(n)$, c'est-à-dire linéaire.
		\end{alphenum}
	\end{MaReponse}

		\begin{MonExo}[Complexité -- note pondérée]
		Soit la fonction suivante:
		\MonPython{Exos_011_NotePonderee.py}
		Déterminer sa complexité.
	\end{MonExo}
	
	\begin{MaReponse}
		Aucun piège ici -- certes, on utilise len(lst\_notes) dans la fonction, mais pas dans le cadre d'une boucle. On n'exécute donc ici que deux opérations: le calcul de res et le return. On est donc dans une complexité constante, soit $\mathcal{O}(1)$.
	\end{MaReponse}
	
	\begin{MonExo}[Complexité -- somme de produits ou produit de sommes?]
		Soit les deux fonctions suivantes:
		\MonPython{Exos_007_ProdSomme.py}
		\MonPython{Exos_006_SommeProd.py}
		\begin{alphenum}
			\item Démontrer (simplement) que si j'applique ces deux fonctions aux mêmes paramètres n1 et n2 leur retour sera identique -- qu'en d'autres termes elles font le même calcul.
			\item Quelles sont les nombres d'opérations élémentaires qu'effectuent chacune de ces deux fonctions (exprimés en fonction de n1 et n2)? Laquelle des deux, du coup, vous semble la meilleure pour atteindre le résultat?
		\end{alphenum}
		
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{alphenum}
			\item On voit de manière évidente que si l'on développe le produit de ProdSomme on tombera sur la somme de SommeProd:
			\begin{align*}
			\text{ProdSomme renvoie: } & [1 + 2 + (...) + (n_1 - 1)] \times [1 + 2 + (...) + (n_2 - 1)] \\
			\text{SommeProd renvoie: } & 1 \times 1 + 1 \times 2 + (...) + (n_1 - 1) \times (n_2 - 1)
			\end{align*}
			\item
			\begin{itemize}
				\item ProdSomme effectue successivement deux boucles de longueurs respectives n1 et n2 -- donc le nombre d'opérations élémentaires qu'elle va effectuer est de l'ordre de $n1 + n2$\footnote{Notez qu'ici on parle bien d'ordre de grandeur et qu'on néglige les opérations unitaires (comme le \texttt{res = 0} ou \texttt{return res}) qui ne changeront rien à la performance de la fonction quand on commencera à utiliser de grandes valeurs de n1 et n2.\label{Neglig}}.
				\item SommeProd, lui, effectue deux boucles \textit{imbriquées}: la boucle \textit{intérieure} (\texttt{for j in range(n2)}) va effectuer n2 itérations tandis que la boucle \textit{extérieure} (\texttt{for i in range(n1)}) va en effectuer n1 -- donc le nombre d'opérations élémentaires qu'elle va effectuer est de l'ordre de $n1 \times n2$\footref{Neglig}.
			\end{itemize}
			Il est donc évident que, pour des valeurs importantes de n1 et n2, ProdSomme sera \textit{beaucoup moins complexe} (et donc beaucoup plus performante) que SommeProd -- et ce pour le même résultat. Si on choisit par exemple n1 = 1.000.000 (un million) et n2 = 2.000.000 alors ProdSomme effectuera environ $n1 + n2 = 3.000.000$ d'opérations, tandis que SommeProd en effectuera environ $n1 \times n2 = 2.000.000.000.000$ (deux mille milliards) -- soit plus de 650.000 fois plus!
		\end{alphenum}
	\end{MaReponse}

		\begin{MonExo}[Tri à bulles - bidouillons-le un peu...]
		On rappelle le code Python du tri à bulles dans sa version la plus basique:
		\MonPython{007_TriBulles.py}
		\begin{alphenum}
			\item A quoi sert l'indice "i" dans cette fonction?
			\item Que se passe-t-il si on remplace la ligne 7 par \texttt{for j in range(n-1, -1, -1)}? Cette syntaxe  -- qui n'est rien de plus qu'une utilisation de la syntaxe \texttt{range} habituelle mais dans le contexte d'une suite décroissante) permet de réaliser une boucle allant de n-2 (le premier paramètre) à 0 (arrêt juste avant d'atteindre le deuxième paramètre) par pas de -1 (le troisième paramètre). L'indice va donc décrire la suite (n-2), (n-3), ..., 1, 0 au lieu de 0, 1, ..., (n-3), (n-2).
			\item Que se passe-t-il si on remplace la ligne 8 par \texttt{if liste[j] < liste[j+1]:}?
			\item La boucle interne ne fait-elle pas des opérations inutiles? Comment la modifier pour la rendre plus efficace?
		\end{alphenum}
		
	\end{MonExo}
	
	\begin{MaReponse}
		\begin{alphenum}
			\item Uniquement à compter le nombre de fois que l'on fait tourner la boucle interne! La variable i, comme on peut le constater, n'est utilisée nulle part hormis dans le \texttt{for} de la boucle.
			\item Eh bien... Rien du tout sur le résultat: on continue à échanger les éléments si celui de droite (d'indice supérieur) est inférieur à celui de gauche, donc on met à terme la liste dans le même ordre que précédemment. En revanche, on s'y prend dans l'autre sens, ce qui modifie la démarche: au lieu de faire "remonter" le plus grand élément du début à la fin de la liste, on va faire ici "descendre" le plus petit de la fin au début. Concrètement, si on passe en entrée la liste qu'on a utilisée en cours (\texttt{[2, 5, 3, 1]} ) on passera par les étapes suivantes:
			\begin{enumerate}
				\item \texttt{[2, 5, 3, 1]}
				\item \texttt{[1, 2, 5, 3]}
				\item \texttt{[1, 2, 3, 5]}
			\end{enumerate}
			\item Là, en revanche, on inverse le sens de tri -- on fait une permutation si l'élément de droite (d'indice supérieur) est \textbf{supérieur} à celui de gauche: donc on obtiendra à la fin la liste triée par ordre décroissant au lieu de croissant.
			\item A la fin de la première itération de la boucle externe (donc quand la boucle interne a fini son travail une première fois), on a ramené le plus grand élément de la liste à la fin de celle-ci; à la fin de la deuxième itération, le deuxième plus grand est en avant-dernière position; (...); à la fin de la i\textsuperscript{ième} itération, le i\textsuperscript{ième} plus grand est en i\textsuperscript{ième} position en partant de la fin, et tous ceux qui le suivent sont positionnés en ordre croissant\footnote{Si vous ne me croyez pas, démontrez-le en utilisant un invariant de boucle -- c'est exactement à cela qu'ils servent!!}. Donc quand on passe à la (i+1)\textsuperscript{ième} itération de la boucle, on a déjà les i éléments "de droite" (de plus grands indices) de la liste qui sont déjà triés et qu'il ne sert plus à rien, de trier de nouveau --  on peut donc modifier la boucle interne pour qu'elle ne regarde plus ces éléments, et donc soit plus optimale, en la faisant aller non plus de 0 à n-2 mais de 0 à n-i-2. Le résultat sera le suivant:
			\MonPython{Exos_012_TriBullesOptim.py}
		\end{alphenum}
	\end{MaReponse}
	
\end{document}
